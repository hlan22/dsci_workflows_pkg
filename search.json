[
  {
    "objectID": "making_a_package.html#python-packages",
    "href": "making_a_package.html#python-packages",
    "title": "Steps For Making A Package",
    "section": "Python Packages",
    "text": "Python Packages",
    "crumbs": [
      "Packages",
      "Package Building"
    ]
  },
  {
    "objectID": "github_actions.html",
    "href": "github_actions.html",
    "title": "github_actions",
    "section": "",
    "text": "GitHub Actions\nWe can make github actions to help automate our processes.\nWe have two main examples we can work with, one from class and one from the website.\nIn order for github actions to work, it needs to be placed in a very specific folder location of: .github/workflows/&lt;file.yml&gt;\nmkdir -p .github/workflows/\ncd .github/workflows/\ncode bash.yml\nThe following is a sample of a github action you can do, where you run a bash command:\nname: Run a bash command # this is what specifies the automation\n\non:\n  workflow_dispatch: # says: manually run this in the github interface...\n  push: # if a push happens to the repo then ...\n    branches: [main] # if a push happens to the main branch also make these changes\n    paths:  # or only trigger when one of these files is changed\n      - 'Dockerfile'\n      - .github/workflows/bash.yml # or whatever you named the file\n      - 'conda-linux-64.lock'\n      # could also do something like every week update it ... etc.\n\njobs: # specify the jobs you want to create\n  run_bash_command: # name of the job, the one yaml understands\n    name: Run a bash command using github actions # a human-readable name that is nice for us to look at\n    runs-on: ubuntu-latest # operating system you want github to run on, this one is most common for linux, you could say windows-latest or mac-latest too\n    steps: # actual steps to run\n      - name: Check out the repo # run git clone and cd into it\n        uses: actions/checkout@v4 # probably automating off something in your repository, so usually your first step\n      - name: Run a command manually\n        run: ls -a\n      - name: Run multiple commands manually # use a vertical bar |\n        run: | \n          pwd\n          ls -a\n      - name: Run multiple commands manually with script\n        run: bash bash_script.sh\nThen you can just commit this file and the action should work!\nThere are also other github actions you can do, of course. Here is one taken from the course textbook that allows you to publish your docker image to docker hub.\n# Publishes docker image, pinning actions to a commit SHA,\n# and updating most recently built image with the latest tag.\n# Can be triggered by either pushing a commit that changes the `Dockerfile`,\n# or manually dispatching the workflow.\n\nname: Publish Docker image\n\non:\n  workflow_dispatch:\n  push:\n    paths:\n      - 'Dockerfile'\n      - .github/workflows/docker-publish.yml # or whatever you named the file\n      - 'conda-linux-64.lock'\n\njobs:\n  push_to_registry:\n    name: Push Docker image to Docker Hub\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }} # do not change, add as secret\n          password: ${{ secrets.DOCKER_PASSWORD }} # do not change, add as secret\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ttimbers/dsci522-dockerfile-practice # change to your image\n          tags: |\n            type=raw, value={{sha}},enable=${{github.ref_type != 'tag' }}\n            type=raw, value=latest\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v6\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\nCheckout https://ubc-dsci.github.io/reproducible-and-trustworthy-workflows-for-data-science/lectures/201-github_actions.html for more customization.\nAlso note that in this one you need to add a secret username and password in the repo you’re in, and you also need to edit to proper naming.",
    "crumbs": [
      "General",
      "GitHub Actions"
    ]
  },
  {
    "objectID": "dependencies.html",
    "href": "dependencies.html",
    "title": "dependencies",
    "section": "",
    "text": "How to find, list, and include dependencies for your package.\n\ndont include packages you dont need to\nthe recommend section\nwhere you can find all packages AND THEIR CURRENT status number thingy\nrelate to renv",
    "crumbs": [
      "Packages",
      "Dependencies"
    ]
  },
  {
    "objectID": "intro_to_git.html",
    "href": "intro_to_git.html",
    "title": "Intro to Git Commands",
    "section": "",
    "text": "Below are some useful tables that can help streamline your workflow in Git Bash.",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "intro_to_git.html#basic-symbols",
    "href": "intro_to_git.html#basic-symbols",
    "title": "Intro to Git Commands",
    "section": "Basic Symbols",
    "text": "Basic Symbols\n\n\n\nTable 1: Basic Symbols\n\n\n\n\n\nSymbol\nDefinition\n\n\n\n\n.\nCurrent working directory\n\n\n..\nParent working directory\n\n\n~\nHome directory\n\n\n-&lt;letter&gt;\nOne dash makes bash only look at the first letter\n\n\n--&lt;word&gt;\nTwo dashes makes bash look at the word as a whole",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "intro_to_git.html#general-bash-commands",
    "href": "intro_to_git.html#general-bash-commands",
    "title": "Intro to Git Commands",
    "section": "General Bash Commands",
    "text": "General Bash Commands\n\n\n\nTable 2: General Bash Commands\n\n\n\n\n\n\n\n\n\nBash Command\nMeaning\n\n\n\n\npwd\nPrints the current working directory path. Stands for “print working directory”\n\n\nls\nLists files and directories in the current directory. Use ls -l for detailed info and use ls -a to see all files. Stands for “listing”. You can also do ls &lt;folder&gt; of a directory of interest that you aren’t currently in!\n\n\ncd &lt;directory&gt;\nSteps into &lt;directory&gt;. Use cd .. to go up to parent file. Stands for “change directory”. cd - takes you to the previous directory you were in, and cd ~ takes you right back to the computer’s home directory.\n\n\nmkdir &lt;directory&gt;\nCreates a new directory named &lt;directory&gt;.\n\n\nrmdir &lt;directory&gt;\nDeletes an empty directory. Use rm -r &lt;directory&gt; to delete non-empty ones.\n\n\nrm &lt;file&gt;\nDeletes a file. Use rm -r &lt;directory&gt; to remove a directory recursively.\n\n\nrestore &lt;file&gt;\nRestores a file to the last commit you pulled (undos changes made)\n\n\ntouch &lt;file&gt;\nCreates an empty file named &lt;file&gt;.\n\n\necho \"text\" &gt; file\nWrites “text” into file, replacing existing content.\n\n\ncat &lt;file&gt;\nDisplays the contents of a file.\n\n\nmv &lt;source&gt; &lt;target&gt;\nMoves or renames a file or directory.\n\n\ncp &lt;source&gt; &lt;target&gt;\nCopies a file. Use -r for recursive copying.\n\n\nclear\nClears the terminal screen.\n\n\nhistory\nShows a list of recently executed commands.\n\n\nhistory &gt; history.txt\nPlaces history into a history.txt file.\n\n\ngrep \"pattern\" file\nSearches for “pattern” in a file.\n\n\nchmod +x &lt;file&gt;\nMakes a file executable.\n\n\nalt+shift+#\nComments out whatever is written in the command line for the history output.",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "intro_to_git.html#git-specific-commands",
    "href": "intro_to_git.html#git-specific-commands",
    "title": "Intro to Git Commands",
    "section": "Git-Specific Commands",
    "text": "Git-Specific Commands\n\n\n\nTable 3: Git Commands\n\n\n\n\n\n\n\n\n\nGit Command\nMeaning\n\n\n\n\ngit init\nInitializes a new Git repository in the current directory.\n\n\ngit clone &lt;repo-url&gt;\nClones a remote repository to your local machine.\n\n\ngit status\nShows the current status of the repository.\n\n\ngit add &lt;file&gt;\nStages a file for the next commit. Use git add . to stage all changes.\n\n\ngit restore &lt;file&gt;\nDiscards any changes in the file in your wd\n\n\ngit commit -m \"msg\"\nCommits staged changes with a message.\n\n\ngit log\nDisplays the commit history of the repository.\n\n\ngit branch\nLists all branches in the repository. Use git branch &lt;name&gt; to create a new branch.\n\n\ngit checkout &lt;branch&gt;\nSwitches to the specified branch.\n\n\ngit switch -c &lt;branch_name&gt; or git checkout -b &lt;new-branch&gt;\nTo create AND switch to a new branch.\n\n\ngit fetch --all\nFetches all changes to all branches\n\n\ngit merge &lt;branch&gt;\nMerges &lt;branch&gt; into the current branch.\n\n\ngit pull\nFetches and integrates changes from the remote repository.\n\n\ngit push\nPushes committed changes to the remote repository.\n\n\ngit push origin &lt;branch_name&gt;\nPushes changes to a remote branch.\n\n\ngit remote -v\nLists the remote repositories linked to the local repository.\n\n\ngit reset --hard &lt;commit&gt;\nResets the repository to a specific commit, discarding all changes.\n\n\ngit stash\nTemporarily saves uncommitted changes. Use git stash pop to reapply them.",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "intro_to_git.html#flags",
    "href": "intro_to_git.html#flags",
    "title": "Intro to Git Commands",
    "section": "Flags",
    "text": "Flags\n\n\n\nTable 4: “Flags” for commands\n\n\n\n\n\n\n\n\n\nFlag\nDefinition\n\n\n\n\n-a\nStands for “all”; often used to show all entries, including hidden ones (e.g., ls -a).\n\n\n-c\nUsed to pass a command string to be executed (e.g., bash -c \"echo Hello\", or git switch -c patch-docs to switch to a branch named patch-docs).\n\n\n-v\nStands for “verbose”, meaning it provides detailed output of the command execution (e.g., git branch -v sees all branches in the repo).\n\n\n-f\nStands for “force”, often used to override warnings or prompts (e.g., rm -f).\n\n\n-r\nStands for “recursive”, allowing commands to act on directories and their contents (e.g., rm -r).\n\n\n-h\nStands for “help”; displays usage information for a command (e.g., ls -h for human-readable sizes).\n\n\n-n\nOften used to indicate a “dry run” where the command is simulated without making actual changes.\n\n\n-p\nCommonly used for “preserve” or “prompt” functionality, depending on the command. In mkdir -p parent/kid, it allows you to make multiple directories without having to do individual commands, so it “preserves” the call for all files.\n\n\n-d\nOften for delete (e.g., git branch -d &lt;branch_name&gt; deletes a local branch)\n\n\n--help\nCan use after most commands to display usage information and available options (e.g., ls --help)",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "intro_to_git.html#commands-for-undoing",
    "href": "intro_to_git.html#commands-for-undoing",
    "title": "Intro to Git Commands",
    "section": "Commands for Undoing",
    "text": "Commands for Undoing\nSpecial thanks to this and this stack overflow response!\n\n\n\n\n\n\n\n\nCommand\nCircumstance\nWhat It Does\n\n\n\n\ngit checkout .\nYou want to discard all uncommitted changes in your working directory.\nReverts all modified files in the working directory to their state in the last commit, leaving staged changes intact.\n\n\ngit restore .\nSame as git checkout ., but for Git version &gt;= 2.23.\nSame as git checkout ., restores working directory files to match the last commit.\n\n\ngit reset\nYou want to unstage all changes in the index (staged changes) while keeping working directory changes.\nResets the index to match the current HEAD, effectively unstaging all changes. Unpushed commits remain unless specified otherwise.\n\n\ngit revert &lt;commit 1&gt; &lt;commit 2&gt;\nYou want to undo specific commits in a branch’s history without altering the commit history.\nCreates new commits that reverse the changes introduced by the specified commits, preserving history.\n\n\ngit clean -f\nYou want to remove untracked files (e.g., new files not yet added to Git).\nDeletes untracked files from the working directory. The -f flag forces the removal.\n\n\ngit clean -fd\nYou want to remove untracked directories (e.g., generated or temporary directories).\nDeletes untracked directories and their contents. The -fd flag forces removal and includes directories.\n\n\ngit reset --hard\nYou want to completely discard all uncommitted changes in both the working directory and index.\nResets the working directory and index to match the current HEAD, erasing all uncommitted changes.\n\n\ngit reset &lt;commit&gt;\nYou want to move the branch pointer to a previous commit, discarding later commits.\nResets the current branch to the specified commit, removing commits after it from history (unless --soft is used).\n\n\ngit reset --soft &lt;commit&gt;\nYou want to keep changes from commits but remove the commits themselves.\nMoves the branch pointer to the specified commit, keeping changes in the working directory and index for re-committing.\n\n\ngit checkout &lt;file&gt;\nYou want to discard changes to a specific file in the working directory.\nReverts the specified file to its state in the last commit, leaving other files unchanged.\n\n\ngit restore &lt;file&gt;\nSame as git checkout &lt;file&gt;, but for Git version &gt;= 2.23.\nReverts the specified file to its state in the last commit, similar to git checkout &lt;file&gt;.\n\n\ngit stash\nYou want to temporarily save uncommitted changes to work on something else.\nSaves uncommitted changes (both staged and unstaged) to a stash, reverting the working directory to the last commit.\n\n\ngit stash pop\nYou want to reapply previously stashed changes and remove them from the stash.\nApplies the most recent stashed changes to the working directory and removes them from the stash.\n\n\ngit revert HEAD\nYou want to undo the most recent commit while keeping the commit history.\nCreates a new commit that reverses the changes made in the last commit (HEAD).\n\n\ngit clean -f -X\nYou want to remove only ignored files (e.g., files matching .gitignore patterns).\nDeletes untracked files that are ignored by Git, useful for cleaning build artifacts.\n\n\ngit clean -f -x\nYou want to remove both ignored and untracked files.\nDeletes all untracked files, including those ignored by Git, with the -f flag to force removal.\n\n\ngit reset --hard &lt;commit&gt;\nYou want to reset the branch and working directory to a specific commit, discarding all changes after it.\nResets the branch, index, and working directory to the specified commit, erasing all subsequent changes.\n\n\ngit reflog\nYou want to recover a commit or branch that was accidentally reset or deleted.\nShows a log of all reference changes (e.g., commits, resets), allowing you to find and restore lost commits using their SHA.\n\n\ngit checkout &lt;commit&gt; -- &lt;file&gt;\nYou want to restore a specific file from a past commit.\nReverts the specified file to its state in the given commit, leaving other files unchanged.\n\n\ngit rm --cached &lt;file&gt;\nYou want to untrack a file but keep it in the working directory.\nRemoves the file from the index (stops tracking it) but leaves the file in the working directory.\n\n\n\nAlso check out this stack overflow response for information about aligning tables!",
    "crumbs": [
      "Basics",
      "Git Commands"
    ]
  },
  {
    "objectID": "quarto_docs.html",
    "href": "quarto_docs.html",
    "title": "quarto_docs",
    "section": "",
    "text": "Side Notes\nQuarto Documents\n\n\n\n\n\n\n\n\nExecution Option\nDescription\nValues\n\n\n\n\neval\nEvaluate the code chunk (if false, just echos the code into the output).\ntrue  false\n\n\necho\nInclude the source code in output.\ntrue  false  fenced\n\n\noutput\nInclude the results of executing the code in the output.\ntrue  false  asis (raw markdown, without Quarto’s standard enclosing markdown)\n\n\nwarning\nInclude warnings in the output.\ntrue  false\n\n\nerror\nInclude errors in the output (note: errors won’t stop document processing).\ntrue  false\n\n\ninclude\nPrevent any output (code or results) from being included.\ntrue  false",
    "crumbs": [
      "Quarto",
      "Quarto Reports"
    ]
  },
  {
    "objectID": "making_websites.html",
    "href": "making_websites.html",
    "title": "Websites With Quarto",
    "section": "",
    "text": "Here’s a basic outline as to how to make websites using quarto (and rstudio/vscode)!",
    "crumbs": [
      "Quarto",
      "Quarto Websites"
    ]
  },
  {
    "objectID": "making_websites.html#website-bones",
    "href": "making_websites.html#website-bones",
    "title": "Websites With Quarto",
    "section": "Website “Bones”",
    "text": "Website “Bones”\nStart with:\nquarto create\n\nSelect project &gt; website &gt; Directory: / &gt; Title: Final Review\n\nAlternatively, create the following files:\n\n_quarto.yml\nindex.qmd\n&lt;project_name&gt;.Rproj\nstyles.css (not necessary)\nother .qmd files (not necessary)\nAdd files to .gitignore",
    "crumbs": [
      "Quarto",
      "Quarto Websites"
    ]
  },
  {
    "objectID": "making_websites.html#main-locations",
    "href": "making_websites.html#main-locations",
    "title": "Websites With Quarto",
    "section": "3 Main Locations",
    "text": "3 Main Locations\nHere are the 3 main locations you can use GitHub Pages for rendering your website!\n\n/(root)\nYou are ready simply by doing:\nSelect the right option in Settings &gt; Pages &gt; Build and deployment &gt; Branch.\nquarto render index.qmd\nThis will make an index.html file that git will look for. If you do not have a index.html file in your root folder, it will instead display your README.md!\nPush all changes, including the rendered page, to the (main branch) repo.\n\n\ndocs/\nThere are a few tasks necessary:\nSelect the right option in Settings &gt; Pages &gt; Build and deployment &gt; Branch.\n\nEnsure docs/ is not blocked in the .gitignore file\nSet output-dir: docs under project: type: in _quarto.yml\n\n\n\ngh-pages branch\nSelect the right option in Settings &gt; Pages &gt; Build and deployment &gt; Branch.\n\nDelete any docs/ folder\nblock the docs and _site folder in the .gitignore file\n\ngit checkout --orphan gh-pages\ngit reset --hard # make sure all changes are committed before running this!\ngit commit --allow-empty -m \"Initialising gh-pages branch\"\ngit push origin gh-pages\nWhich now you can test-run the website with:\ngit switch main\nquarto publish gh-pages\nYou can still use the regular quarto render or quarto preview to build your site locally, but you will no longer need to manually build and push the site to the main branch!\nAdd a github action to make it automatically build:\ncode .github/workflows/build.yml\nAnd copy the following contents into it:\non:\n  workflow_dispatch:\n  push:\n    branches: main\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}",
    "crumbs": [
      "Quarto",
      "Quarto Websites"
    ]
  },
  {
    "objectID": "git_concepts.html",
    "href": "git_concepts.html",
    "title": "Basic Git Concepts",
    "section": "",
    "text": "GitHub is the remote repository where you commit changes to the version control history. At a minimum, you should at least push your work to GitHub at the end of every work session.",
    "crumbs": [
      "Basics",
      "Git Concepts"
    ]
  },
  {
    "objectID": "git_concepts.html#branches",
    "href": "git_concepts.html#branches",
    "title": "Basic Git Concepts",
    "section": "Branches",
    "text": "Branches\n\nThe benefits of branches:\n\nBranches allow you to have a playground for developing and testing new additions to your code, as well as fixes. This playground lets your explore, experiment and test in a safe place - away from others that might be using or depending on the current version of your code.\nThis is perhaps more obviously useful if your project is deployed and has users (e.g., a data visualization dashboard, an R or Python package, a phone app, etc), but this can also be useful for code that make up a data analyses. Because, in addition to the reasons stated above for branching, branching also lets you organize units of work into smaller, more manageable chunks that are easier for collaborators to check over and review.\nSeveral branch playgrounds can co-exist, one for each new code addition or fix being worked on. This allows for parallelization of work!\n\n\n\nCreating a pull-request:\n\nTo create a pull request, you click the green button Compare & pull request. In the new page, add a message to describe the changes you have made, scroll down to review the changed files, and the click the green button that reads Create pull request. If you are working together in a team, you could also designate certain team members to review your work and assign relevant labels, via the right hand side panel.\nThe next step is for a collaborator to review your work and merge it in if they approve it.\nTutorial 2 is all about creating branches and pull requests. It also makes you create two branches and see the conflict when you try and pull them both despite them editing the same place. This ends in a merge conflict that you can solve in the github interface.",
    "crumbs": [
      "Basics",
      "Git Concepts"
    ]
  },
  {
    "objectID": "git_concepts.html#github-worklow-and-git-flow",
    "href": "git_concepts.html#github-worklow-and-git-flow",
    "title": "Basic Git Concepts",
    "section": "GitHub Worklow and Git Flow",
    "text": "GitHub Worklow and Git Flow\n\nGitHub Workflow\n\nFeatures a single “main” branch that also serves as the deployment branch, we call this main.\n\nEvery new contribution is done on a new branch (with a meaningful name) created from main.\nContributions from that new branch are sent back to main by means of a pull request, which ideally is reviewed & tested before merging.\n\n\n\n\nGit Flow\n\nTwo “main” branches that last forever, main for deployment and develop where things are tested before they are released to main.\nThree supporting branches: feature, release & hotfix. Both feature & release branches are created from develop. feature branches should be merged into develop before they are incorporated into a release. release branches eventually get merged into main after adequate review and testing.",
    "crumbs": [
      "Basics",
      "Git Concepts"
    ]
  },
  {
    "objectID": "git_concepts.html#merge-conflicts",
    "href": "git_concepts.html#merge-conflicts",
    "title": "Basic Git Concepts",
    "section": "Merge conflicts",
    "text": "Merge conflicts\n\nIMPORTANT: You must know how to deal with multiple types of merge conflicts\nYou need to know how to resolve basic file merge conflicts, but also branch merge conflicts\nThe two main types of branch merge conflict resolutions involve:\n\nManually push back in changes\nRestructure commits so that changes are pushed at a later date\n\n\n\nMerge Branches\nWhat happens when a branch falls behind main? There are two ways you can update the branch.\n\nUsing merge\n\n\nHow to catch up a branch that has fallen behind the main branch using the command line:\n\nrun git pull origin main to pull any changes from the remote version of main that we might not have\nrun git switch &lt;branch&gt; to make sure we are on the branch we want to catch up\nrun git merge main to merge the changes\nrun git push origin &lt;branch&gt; to push our updated branch to the remote\n\n\nThis bash code is rewritten below for copying convenience:\ngit pull origin main\ngit switch &lt;branch&gt;\ngit merge main\ngit push origin &lt;branch&gt;\n\nUsing rebase\n\nMake sure everything is committed in your new branch\nMove to the main branch: git switch main\nMake sure the main branch is up to date: git pull origin main\nMove back over to your branch: git switch &lt;branch&gt;\nUpdate the changes from main: git rebase main\n\n\nThis bash code is rewritten below for copying convenience:\ngit switch main\ngit pull origin main\ngit switch &lt;branch&gt;\ngit rebase main\n\n\nPersonal Access Tokens (PAT)\nPATs are important!",
    "crumbs": [
      "Basics",
      "Git Concepts"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSCI 310 Final Exam Review",
    "section": "",
    "text": "Welcome to my DSCI 310 Final Exam Review!\nThis is a review of DSCI 310, but specifically for topics that will be covered on the final. This means there will be less emphasis on topics such as Docker containers, git basics, Renv, etc.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "DSCI 310 Final Exam Review",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nBy the end of the course, students will be able to:\n\nDefend and justify the importance of creating data science workflows that are reproducible and trustworthy and the elements that go into such a workflow (e.g., writing clear, robust, accurate and reproducible code, managing and sharing compute environments, defined collaboration strategies, etc).\nConstructively criticize the workflows and data analysis of others in regards to its reproducibility and trustworthiness.\nDevelop a data science project (including code and non-code documents such as reports) that uses reproducible and trustworthy workflows\nDemonstrate how to effectively share and collaborate on data science projects and software by creating robust code packages, using reproducible compute environments, and leveraging collaborative development tools.\nDefend and justify the benefit of, and employ automated testing regimes, continuous integration and continuous deployment for managing and maintaining data science projects and packages.\nDemonstrate strong communication, teamwork, and collaborative skills by working on a significant data science project with peers throughout the course.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#outline-of-assessments",
    "href": "index.html#outline-of-assessments",
    "title": "DSCI 310 Final Exam Review",
    "section": "Outline of Assessments",
    "text": "Outline of Assessments\n\nAssignments\n\nAssignment 1: (Not Included) Setup and Installation (you can find them here)\nAssignment 2: Git merge conflicts (learn more here)\n\nNote: Make a review of the different types of conflicts\n\nAssignment 3: (Not Included) Dockerfiles\nAssignment 4: Reproducible reports using Quarto\n\nNote: Need to make a summary page that lists all improvements possible\n\nAssignment 5: Packaging (for walk-through, see this for R or this for python)\n\nNote: Need to learn how to do python packages\nNote: Need to summarize and streamline R packages\nNote: Want to improve and update R packages made from this course\nNote: Want to go over potential conflicts you can run into, and main things to know in a time crunch\n\n\n\n\nTutorials\n\nTutorial 1: Setup\nTutorial 2: Git Basics\n\nNote: Transfer git basics info from dsci-review repo\n\nTutorial 3: R and Python Environments (renv and conda)\nTutorial 4: Environments and Docker Containers\nTutorial 5: Bash Scripts and Github Actions\nTutorial 6: Refactoring a Quarto Report\nTutorial 7: Quarto and Github Pages\nTutorial 8: Writing Tests using testthat for R or pytest for Python\nTutorial 9: Create a Quarto Website (using gh-pages)\n\nNote: Making a Website (through main, docs, and gh-pages)\n\nTutorial 10: Packaging (work period for Assignment 5)\nTutorial 11: Packaging with Continuous Integration and Continuous Deployment\n\n\n\nMilestones\n\nMilestone 1: Data Analysis, Docker, Git basics\nMilestone 2: Abstract code, Quarto doc, Makefile\n\nNote: Transfer information about Makefiles from dsci-review repo\n\nMilestone 3: Abstract functions, Testing, Validation\nMilestone 4: Packaging, Documentation, and Fixing previous issues\n\n\n\nOther\n\nReview the Textbook\nReview Lecture Notes\nReview Lecture Concepts",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#final-exam-information",
    "href": "index.html#final-exam-information",
    "title": "DSCI 310 Final Exam Review",
    "section": "Final Exam Information",
    "text": "Final Exam Information\n\nThe best way to study is to look though the in-class examples, individual assignments, and be comfortable with all the mechanics you were asked to do for your milestone assignments.\nThink of the final as an individual assessment for everything you were asked to do for the project milestones.\nYou will have 2 hours for the exam. For reference, it took [the professor] just under 30 minutes to get though it.\nBelow is the instructions that you will see before the exam. The format is the same as the midterm.\n\n\nFinal Exam Instructions\nWelcome to your final exam for the course!\n\nTopics Covered:\n\nInteract with Git + GitHub with branches and pull requests.\nSplit a monolithic report into separate scripts.\nUse a Makefile to run your analysis code.\nAdd functions and unit tests to a package.\nCreate a functioning R package.\n\n\nExam Notes\n\nThis exam will have you use an exam template repository to practice the skills we have covered in class this term.\nYou will not be building a full report or full package from scratch. We have provided a skeleton for you to work with.\nAI / LLM / ChatBots are allowed for the exam\nYou are not allowed to communicate or collaborate with another human / classmate during the exam.\n\n\n\nNew Skill Necessary\nThere may be a new mechanics you will need to get access to the exam, specifically copying a template repository into the organization. If this is new to you and you want an example to practice for:\n\nGo to https://github.com/DSCI-310/template-repository-example\nClick the green “Use this template” button\nSelect “Create a new repository”\nLeave the “Include all branches” unchecked.\nSet the ownership to your own account, rename the repo as needed - For the exam, you will use the course organization and have a specific repo name for the exam\nTreat this “template” that you have copied into your account as a new repository. It is pre-populated with files so you are not starting from a completely empty repository.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#credit",
    "href": "index.html#credit",
    "title": "DSCI 310 Final Exam Review",
    "section": "Credit",
    "text": "Credit\nAlthough this repo is made by Heidi, credit goes towards Daniel Chen and other contributors for the DSCI 310 course for most material in the repo. Thanks!",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "bash_scripts.html",
    "href": "bash_scripts.html",
    "title": "Bash Scripts",
    "section": "",
    "text": "What are they? A bash script is a .sh (shell) document that contains bash commands, which you can run from the terminal. They are often useful if you have the same bash lines you need to run repetitively when working on a project.\nWe can make a sample bash_script.sh by typing:\nHere is a sample of what you can put in a bash script:\nWe can run the file by typing into terminal:",
    "crumbs": [
      "Basics",
      "Bash Scripts"
    ]
  },
  {
    "objectID": "bash_scripts.html#other-notes",
    "href": "bash_scripts.html#other-notes",
    "title": "Bash Scripts",
    "section": "Other notes:",
    "text": "Other notes:\nSometimes there are files in our computer’s filesystem that are prefixed with ., for example .gitignore, .DS_Store and .ipynb_checkpoints. These are known as hidden files, and your computer’s default is to hide them from you, regardless of whether you use a graphical user interface (e.g., Finder, Explorer, Nautilus) or the Bash shell to explore our computer’s filesystem.\n\nWhat is SSH authentication?\nSSH stands for secure shell protocol (for authentication). SSH can be use for other forms of authentication as well (beyond GitHub), including logging into remote machines in the cloud. So for many these reasons it is worthwhile learning.\nSee this link to SSH part in the textbook for more information on SSH.",
    "crumbs": [
      "Basics",
      "Bash Scripts"
    ]
  },
  {
    "objectID": "bash_scripts.html#bash-scripts-for-package-making",
    "href": "bash_scripts.html#bash-scripts-for-package-making",
    "title": "Bash Scripts",
    "section": "Bash Scripts for Package Making",
    "text": "Bash Scripts for Package Making\n!!!",
    "crumbs": [
      "Basics",
      "Bash Scripts"
    ]
  },
  {
    "objectID": "supporting.html#contribution-document",
    "href": "supporting.html#contribution-document",
    "title": "supporting",
    "section": "Contribution Document",
    "text": "Contribution Document",
    "crumbs": [
      "Packages",
      "Badges, Licenses & More"
    ]
  },
  {
    "objectID": "supporting.html#code-of-conduct",
    "href": "supporting.html#code-of-conduct",
    "title": "supporting",
    "section": "Code of Conduct",
    "text": "Code of Conduct",
    "crumbs": [
      "Packages",
      "Badges, Licenses & More"
    ]
  },
  {
    "objectID": "supporting.html#licenses",
    "href": "supporting.html#licenses",
    "title": "supporting",
    "section": "Licenses",
    "text": "Licenses",
    "crumbs": [
      "Packages",
      "Badges, Licenses & More"
    ]
  },
  {
    "objectID": "supporting.html#readme.md-outline",
    "href": "supporting.html#readme.md-outline",
    "title": "supporting",
    "section": "README.md Outline",
    "text": "README.md Outline\n(or README.Rmd outline for that matter)",
    "crumbs": [
      "Packages",
      "Badges, Licenses & More"
    ]
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "tests",
    "section": "",
    "text": "testthat Package\n\n\ncodecov Package",
    "crumbs": [
      "Packages",
      "Testing"
    ]
  },
  {
    "objectID": "environments.html",
    "href": "environments.html",
    "title": "Environments",
    "section": "",
    "text": "Create an RStudio project fpr the repo\nInstall renv package if you haven’t already\nInitialize project as an renv project\nInstall new R package (.lock file will not update until you use it)\nCreate (and save) R script that uses the new R package\n\ninstall.packages(\"renv\")\nrenv::init()\ninstall.packages(\"cowsay\")\nrenv::snapshot()\nAnd there you have an R environment!",
    "crumbs": [
      "General",
      "Environments"
    ]
  },
  {
    "objectID": "environments.html#r-environments-renv",
    "href": "environments.html#r-environments-renv",
    "title": "Environments",
    "section": "",
    "text": "Create an RStudio project fpr the repo\nInstall renv package if you haven’t already\nInitialize project as an renv project\nInstall new R package (.lock file will not update until you use it)\nCreate (and save) R script that uses the new R package\n\ninstall.packages(\"renv\")\nrenv::init()\ninstall.packages(\"cowsay\")\nrenv::snapshot()\nAnd there you have an R environment!",
    "crumbs": [
      "General",
      "Environments"
    ]
  },
  {
    "objectID": "environments.html#python-environments",
    "href": "environments.html#python-environments",
    "title": "Environments",
    "section": "Python Environments",
    "text": "Python Environments",
    "crumbs": [
      "General",
      "Environments"
    ]
  },
  {
    "objectID": "ci_cd.html",
    "href": "ci_cd.html",
    "title": "ci_cd",
    "section": "",
    "text": "Continuous Integration and Deployment",
    "crumbs": [
      "General",
      "CI & CD"
    ]
  },
  {
    "objectID": "docker.html",
    "href": "docker.html",
    "title": "docker",
    "section": "",
    "text": "Containers\n\nBasic container\nWhat is a container?\n\nthey are basically a virtual machine, where you can specify all the software you need to run files you want.\n\ndocker run hello-world\nThis command runs a container that executes a script that prints out the hello docker text. When this script runs, it exits and the container exits to give you your prompt back\n\n\nAn R Container\nWith this code you can run an R container:\ndocker run --rm -it rocker/r-ver:4.3.2\nYou can open up and launch R or run R --version to get your current R version.\n\n\nAn RStudio Container\nWith this code you can run an RStudio container:\ndocker run --rm -e PASSWORD=\"pizza\" -p 8787:8787 rocker/rstudio:4.4.2\nHere are what the commands mean:\n\n--rm means remove. It is saying to delete the container when I am done with it!\n-e stands for environments. It lets you pass in special parameters necessary to run that container.\n-p stands for port. It is where you specify the container will be run through on your computer.\n\nAfter running it, you can visit http://localhost:8787 and view the RStudio container.\nIf you create any files in this container instance, all your work will be lost!\n\nAn RStudio Tidyverse Container\nYou can also make a Tidyverse container, where tidyverse is already installed! Pretty sweet.\ndocker run --rm -e PASSWORD=\"pizza\" -p 8787:8787 rocker/tidyverse:4.4.2\nNote that if you run two sessions at once, you will need to change the port mapping on one of them.\n\nhttp://localhost:8888 is commonly known for jupyterlab\n\n\n\n\nDockerFiles\nA Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image.\nYou can create it simply with the command code Dockerfile.\nIt is a special type of file, so make sure it does NOT end with something like .txt or .sh or anything. It is simply just Dockerfile (with a capital D).\nThe following is a sample of what you can do with a Dockerfile:\nFROM rocker/rstudio:4.2.2\n# this builds the base image from rstudio\n\n# you can run basic bash commands that will run while setting up the container\nRUN echo \"Hello\"\nRUN pwd\n\n# you can install apps and such so that you have them in your image\nRUN apt-get install -y git\n\n# you can copy files onto your image/container\nCOPY renv.lock /home/rstudio/renv.lock\nCOPY README.md /home/rstudio/README.md \n\n# we can even install packages into the image\nRUN Rscript -e \"install.packages('renv', repos = c(CRAN = 'https://cloud.r-project.org'))\"\n# with the renv package we can keep r packages in our image without having to manually download them each time\n# we have to set the working directory first\nWORKDIR /home/rstudio\n# then we can copy other project files\nCOPY renv/ /home/rstudio/renv\nCOPY bash_script.sh /home/rstudio/bash_script.sh\nCOPY newRpackage_usage.R /home/rstudio/newRpackage_usage.R \n\n# however!\n# Installing the remotes package allows us to pin the version of the package we're installing\nRUN Rscript -e \"install.packages('remotes', repos = c(CRAN = 'https://cloud.r-project.org'))\"\n# now we can install a package like this:\nRUN Rscript -e \"remotes::install_version('cowsay', version='1.0.0')\"\n# this saves us the hassle of having to copy all of our project files\n# while still keeping the package versions we want!\n\nRUN echo \"Wow! There are so many things you can do with Dockerfiles!\"\nNow that you have completed your super-cool Dockerfile, you can now build your very OWN container! How exciting!\n\nBuilding and Running ‘mycontainer’\nAssuming you’ve made your own Dockerfile, you can now build your own container with this command:\ndocker build --tag mycontainer .\nNote you can replace mycontainer with whatever you would like your container to be called. Also note that it is very important to have the . at the end, as that is for your current working directory. This command will look for a Dockerfile within your current directory and then build the container.\nThe command docker images will let you see what images you have going.\nAfter you have built your container, you can now run it using:\ndocker run --rm -it -e PASSWORD=\"pizza\" -p 8787:8787 -v /$(pwd):/home/rstudio/work mycontainer\n\nNote you replacemycontainer with the name of the container you just build, and can of course replace the password.\nAlso note that the -v stands for volume. It will copy all of your local files into the container (just for you when you run it) for you to be able to use at ease.\n\nWhat if I am too lazy to type that long run command? Let’s learn about .yml files where you can run the docker in a much easier way!\n\nSide note: after you build you container you can also push it to docker so that anyone can use it\n\n\n\nRunning docker easier\nWe can create a special docker-compose.yml file where we are saved from having to write a long run command line. Note that docker specifically recognizes this file name, so the naming convention is important.\nHere is a sample of what one would look like:\nservices:\n  analysis-env:\n    image: hlan22/mycontainer\n    ports:\n      - \"8787:8787\"\n    volumes:\n      - .:/home/rstudio/work\n    environment:\n      PASSWORD: \"pizza\"\n\n# This file is a replacement for having to write the following command line\n# docker run --rm -it -e PASSWORD=\"pizza\" -p 8787:8787 \n# -v /$(pwd):/home/rstudio/work rocker/tidyverse:4.4.2\nTo run this file, you just need to type the following:\ndocker-compose up\nAlthough, with this method, you need to remove it manually afterwards with:\ndocker-compose rm",
    "crumbs": [
      "General",
      "Docker Containers"
    ]
  }
]